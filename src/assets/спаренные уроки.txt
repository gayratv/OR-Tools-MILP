нужно добавить новый компонент в целевую функцию - предпочтение спаренных предметов для ряда предметов

в input_data.py добавлен новый элемент paired_subjects
paired_subjects = {"labor"}

paired_subjects - это set предметов по которым предпочтительно ставить уроки подряд
это может быть труд/технология
физкультура

если предмет делится на подгруппы, то предмет должен быть спарен у одной и той же подгруппы

например

 предмет спарен у класса 10A если
 первое назначение labor 3 уроком
 z[("10A", "labor", 1 , "Mon", 3)]=1
 z[("10A", "labor", 2 , "Mon", 3)]=1

 второе назначение labor 4 уроком
 z[("10A", "labor", 1 , "Mon", 4)]=1
 z[("10A", "labor", 2 , "Mon", 4)]=1


 если предмет не делится на подгруппы, то уроки должны идти подряд
    первое назначение math 3 уроком
    x[("10A", "math", "Mon", 3)]=1

    второе назначение math 4 уроком
    x[("10A", "math", "Mon", 4)]=1


============

минимизировать количество "одиноких" уроков.
1.Итерация по предметам: Мы проходим по всем предметам из data.paired_subjects.
2.Разделение логики: Код отдельно обрабатывает делимые (splitS) и неделимые предметы.
3.Поиск "одиночек": Для каждого урока из списка paired_subjects мы проверяем, есть ли у него "сосед"
(такой же урок того же класса/подгруппы) на предыдущем или следующем временном слоте.
4.Переменная is_lonely: Если у урока нет ни предыдущего, ни последующего соседа, мы помечаем его как "одинокий"
с помощью вспомогательной булевой переменной is_lonely.
5.Минимизация: В целевую функцию добавляется сумма всех переменных is_lonely, умноженная на весовой коэффициент epsilon_pairing.
Таким образом, решатель получает штраф за каждый урок, который он не смог спарить,
что напрямую мотивирует его создавать пары, где это возможно, для минимизации целевой функции.

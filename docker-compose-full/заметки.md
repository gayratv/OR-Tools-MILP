6) (Опционально) Включить TLS для внешних клиентов

Рекомендуется шифровать соединение.

docker compose up -d --build
docker compose down

Логи конкретного сервиса:
docker compose logs -f db
docker compose logs -f nodejs
docker compose logs -f nginx


Находясь в каталоге с вашими файлами (docker-compose.yml и .env):
docker compose up -d

Проверить, что переменные подставились
docker compose config

Проверить, что порт открыт на VPS
netstat -tuln | grep 45321

Проверить соединение клиентом MySQL
mysql -h 127.0.0.1 -P 45321 -u"$MYSQL_USER" -p"$MYSQL_PASSWORD" "$MYSQL_DATABASE"

sudo apt update
sudo apt install mysql-client -y

docker exec -it mysql8 mysql -u"$MYSQL_USER" -p"$MYSQL_PASSWORD" "$MYSQL_DATABASE"

# передаём пароль в окружении, чтобы убрать предупреждение
docker exec -it -e MYSQL_PWD='2^hcG9#Ktn' mysql8 \
  mysql -h 127.0.0.1 -P 3306 -u appuser school_sheduller -e "SELECT 1;"

docker exec -it -e MYSQL_PWD='2^hcG9#Ktn' mysql8 \
  sh -lc 'mysql -h 127.0.0.1 -P 3306 -u "$MYSQL_USER" "$MYSQL_DATABASE" -e "SELECT 1;"'


docker exec -it mysql8 bash
MYSQL_PWD='2^hcG9#Ktn' mysql -h 127.0.0.1 -P 3306 -u "$MYSQL_USER" "$MYSQL_DATABASE" -e "SELECT 1;"

set -a
source .env
set +a


scp -i ~/.ssh/id_rsa -r ./mysql user@vps.example.com:/home/user/

scp -i ~/.ssh/vps_key -r ./mysql-on-vps user@<VPS_IP_OR_HOSTNAME>:/home/user/


Запуск
# из корня проекта
docker compose up -d --build

curl http(s)://<ваш_домен_или_IP>/
# или напрямую если без nginx: curl http://<IP_VPS>:3000/


===================
Быстрая проверка

Перезапуск:

docker compose down && docker compose up -d


Изнутри контейнера:

docker exec -it mysql8 mysql --ssl-mode=REQUIRED -uroot -p"$MYSQL_ROOT_PASSWORD" \
  -e "SHOW VARIABLES LIKE 'have_ssl'; SHOW STATUS LIKE 'Ssl_cipher';"


С удалённой машины (скопируйте ca.pem):

mysql --ssl-mode=VERIFY_IDENTITY --ssl-ca=/путь/к/ca.pem \
  -h <ваш_домен> -P <ваш_порт> -u appuser -p

===========
С удалённой машины

Скопируйте ca.pem на клиентскую машину (например, в ~/.mysql/ca.pem) и подключайтесь:

mysql --ssl-mode=VERIFY_CA --ssl-ca=/path/to/ca.pem \
  -h example.com -P 45321 -u appuser -p


REQUIRED — примет любой валидный TLS (без проверки CA/имени хоста).

VERIFY_CA — проверит, что сертификат подписан вашим CA.

VERIFY_IDENTITY — дополнительно проверит совпадение имени хоста (CN/SAN) с -h.

Если вы правильно указали subjectAltName=DNS:example.com, смело используйте --ssl-mode=VERIFY_IDENTITY.